#!/usr/bin/env python3

# generated by deepseek.com
# prompts:
"""
show me a python script
that takes an m4a file
(with aac audio)
and detects
the audio encoder's
lowpass filter
"cutoff frequency" in khz,
for example 20 khz
for high-quality audio,
or 10 khz for low-quality audio
"""
"""
please make matplotlib
write the debug plot
to a png file at
f"{input_file_path}.debug-spectrum.png".
also please avoid
creating a temporary wav file,
and try to use ffmpeg
to write wav data to stdout,
and feed that wav data
to wavfile and numpy.
generally,
try to use a streaming algorithm
to reduce memory usage.
"""
"""
no, this still runs out of memory at
```py
stdout_data, stderr_data = proc.communicate()
```
please use a loop to read
chunks of wav data from ffmpeg
and process each chunk separately.
feel free to use
a different format than wav
to make the code easier.
"""
"""
for debugging, print the
intermediate cutoff_khz result
with every loop iteration.
increase the buffer size
to make the loop run
at a lower frequency.
"""
"""
something is wrong here.
the script keeps printing 0 khz
but it should be about 19.6 khz
pretty much from the start
in my example.
"""
"""
now it keeps printing 1.5 kHz
but it should be about 19.6 khz.
im looking for
the maximum frequency of the signal
above a certain loudness,
dont count quiet noise spikes.
"""

#!/usr/bin/env python3

import numpy as np
from scipy import signal
import subprocess
import sys
import matplotlib.pyplot as plt

def detect_lowpass_cutoff(m4a_file_path, plot_path=None):
    """Process audio in chunks using ffmpeg stdout streaming"""
    # FFmpeg command for raw PCM output
    ffmpeg_cmd = [
        'ffmpeg',
        '-i', m4a_file_path,
        '-ac', '1',          # mono
        '-ar', '44100',      # sample rate
        '-f', 's16le',       # 16-bit little-endian PCM
        '-'                   # output to stdout
    ]

    # Audio processing parameters
    sample_rate = 44100
    chunk_duration = 10  # seconds per chunk
    chunk_size = sample_rate * chunk_duration
    bytes_per_sample = 2  # 16-bit = 2 bytes
    
    # Frequency analysis parameters
    # ignore anything quieter than this
    min_threshold_db = -80
    # Focus on 8-24kHz range
    target_freq_range = (8000, 24000)
    
    # Start ffmpeg process
    proc = subprocess.Popen(ffmpeg_cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        bufsize=10**8,
    )

    try:
        all_frequencies = None
        spectrum_sum = None
        total_chunks = 0
        
        while True:
            # Read and process chunk
            raw_bytes = proc.stdout.read(chunk_size * bytes_per_sample)
            if not raw_bytes:
                break

            # Convert to numpy array
            chunk = np.frombuffer(raw_bytes, dtype=np.int16).astype(np.float32)
            chunk /= 32768.0  # Normalize to [-1, 1]

            # Skip silent chunks
            if np.max(np.abs(chunk)) < 0.01:
                continue

            # Compute FFT with high resolution
            window = signal.windows.hann(len(chunk))
            windowed = chunk * window
            fft_result = np.fft.rfft(windowed)
            fft_freq = np.fft.rfftfreq(len(chunk), d=1.0/sample_rate)
            
            # Convert to power spectrum in dB
            power_spectrum = np.abs(fft_result) ** 2
            power_db = 10 * np.log10(power_spectrum + 1e-10)

            # Initialize or accumulate spectrum
            if spectrum_sum is None:
                spectrum_sum = power_spectrum
                all_frequencies = fft_freq
            else:
                # Handle different FFT sizes by resampling to common grid
                if len(spectrum_sum) != len(power_spectrum):
                    # Resample to the longer array
                    max_length = max(len(spectrum_sum), len(power_spectrum))
                    spectrum_sum = np.interp(np.linspace(0, 1, max_length), 
                                           np.linspace(0, 1, len(spectrum_sum)), 
                                           spectrum_sum)
                    power_spectrum = np.interp(np.linspace(0, 1, max_length), 
                                              np.linspace(0, 1, len(power_spectrum)), 
                                              power_spectrum)
                    all_frequencies = np.linspace(0, sample_rate/2, max_length)
                
                spectrum_sum += power_spectrum
            
            total_chunks += 1

            # Calculate current average spectrum
            current_avg = spectrum_sum / total_chunks
            current_db = 10 * np.log10(current_avg + 1e-10)

            # Find maximum frequency above threshold in target range
            freq_mask = (all_frequencies >= target_freq_range[0]) & \
                       (all_frequencies <= target_freq_range[1])
            valid_db = current_db[freq_mask]
            valid_freq = all_frequencies[freq_mask]
            
            # Find the highest frequency with power above threshold
            above_threshold = valid_freq[valid_db >= min_threshold_db]
            if len(above_threshold) > 0:
                max_freq = above_threshold[-1]
            else:
                max_freq = 0

            print(f"Chunk {total_chunks}: "
                  f"Max significant frequency: {max_freq/1000:.1f} kHz "
                  f"(SNR: {np.max(valid_db)-min_threshold_db:.1f} dB)")

    finally:
        proc.terminate()
        try:
            proc.wait(timeout=1)
        except:
            pass

    # Final calculation
    if spectrum_sum is None:
        raise ValueError("No valid audio data processed")
    
    final_avg = spectrum_sum / total_chunks
    final_db = 10 * np.log10(final_avg + 1e-10)
    
    # Find maximum frequency in target range
    freq_mask = (all_frequencies >= target_freq_range[0]) & \
               (all_frequencies <= target_freq_range[1])
    valid_db = final_db[freq_mask]
    valid_freq = all_frequencies[freq_mask]
    
    above_threshold = valid_freq[valid_db >= min_threshold_db]
    if len(above_threshold) > 0:
        max_freq = above_threshold[-1]
    else:
        max_freq = 0
    
    # Save debug plot
    if plot_path:
        plt.figure(figsize=(10, 4))
        plt.semilogx(all_frequencies, final_db)
        plt.axvline(x=max_freq, color='r', linestyle='--',
                   label=f'Max significant freq: {max_freq/1000:.1f} kHz')
        plt.axhline(y=min_threshold_db, color='gray', linestyle=':',
                   label=f'Threshold ({min_threshold_db} dB)')
        plt.xlabel('Frequency (Hz)')
        plt.ylabel('Power (dB)')
        plt.title('Frequency Spectrum Analysis')
        plt.legend()
        plt.grid(True)
        plt.xlim(1000, 20000)
        plt.savefig(plot_path)
        plt.close()
    
    return max_freq / 1000  # Return in kHz

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python detect_lowpass.py <input.m4a>")
        sys.exit(1)
    
    try:
        cutoff = detect_lowpass_cutoff(sys.argv[1])
        print(f"\nFinal maximum significant frequency: {cutoff:.1f} kHz")
    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        sys.exit(1)
