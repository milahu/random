#!/usr/bin/env python3

# generated by deepseek.com
# prompts:
"""
show me a python script
that takes an m4a file
(with aac audio)
and detects
the audio encoder's
lowpass filter
"cutoff frequency" in khz,
for example 20 khz
for high-quality audio,
or 10 khz for low-quality audio
"""
"""
please make matplotlib
write the debug plot
to a png file at
f"{input_file_path}.debug-spectrum.png".
also please avoid
creating a temporary wav file,
and try to use ffmpeg
to write wav data to stdout,
and feed that wav data
to wavfile and numpy.
generally,
try to use a streaming algorithm
to reduce memory usage.
"""
"""
no, this still runs out of memory at
```py
stdout_data, stderr_data = proc.communicate()
```
please use a loop to read
chunks of wav data from ffmpeg
and process each chunk separately.
feel free to use
a different format than wav
to make the code easier.
"""
"""
for debugging, print the
intermediate cutoff_khz result
with every loop iteration.
increase the buffer size
to make the loop run
at a lower frequency.
"""
"""
something is wrong here.
the script keeps printing 0 khz
but it should be about 19.6 khz
pretty much from the start
in my example.
"""
"""
now it keeps printing 1.5 kHz
but it should be about 19.6 khz.
im looking for
the maximum frequency of the signal
above a certain loudness,
dont count quiet noise spikes.
"""
"""
now the buffer size is too small,
so the intermediate result
is printed too often.
also, it always says
"Current peak: 0.5 kHz"
which is waay too low
"""
"""
now it prints 17.8 kHz
instead of 19.5 khz.
closer but still not perfect
"""
"""
you should
1. get the spectrogram of a chunk
2. remove noise (quiet signals)
3. use `numpy.argmax` on the spectrogram
to get the maximum frequency 
"""
"""
the script just hangs.
for debugging,
add a `--ss` and `--to n` option,
and pass them to ffmpeg as `-ss n` and `-to n`.
"""
"""
now it says 22.0 kHz as final result
but it does not print intermediary results.
"""

#!/usr/bin/env python3

import numpy as np
import subprocess
import sys
import argparse
import matplotlib.pyplot as plt
from scipy import signal

def process_chunk(audio, sample_rate, chunk_num, start_time):
    """Process 10-second audio chunk and return cutoff frequency estimate"""
    # Apply window function
    window = signal.windows.hann(len(audio))
    fft = np.fft.rfft(audio * window, n=len(audio)*4)  # 4x zero-padding
    freqs = np.fft.rfftfreq(len(audio)*4, d=1/sample_rate)
    db = 20 * np.log10(np.abs(fft) + 1e-10)
    
    # Analysis parameters
    min_freq = 18000
    max_freq = 20000
    rolloff_db = 3
    
    # Find cutoff frequency
    mask = (freqs >= min_freq) & (freqs <= max_freq)
    target_freqs = freqs[mask]
    target_db = db[mask]
    
    if len(target_db) == 0:
        return None

    # Find peak and cutoff
    peak_idx = np.argmax(target_db)
    peak_db = target_db[peak_idx]
    cutoff_db = peak_db - rolloff_db
    
    above_threshold = np.where(target_db >= cutoff_db)[0]
    if len(above_threshold) == 0:
        return None
    
    cutoff_idx = above_threshold[-1]
    cutoff_freq = target_freqs[cutoff_idx]
    
    """
    # Print intermediate result
    # print(f"Chunk {chunk_num}: Current estimate: {cutoff_freq/1000:.1f} kHz")
    if chunk_num % 6 == 0:
      chunk_time = start_time + chunk_num * 10
      print(f"t={chunk_time}sec f={cutoff_freq/1000:.1f}kHz")
      # todo print final_cutoff
    """
    
    return cutoff_freq, freqs, db

def get_lowpass_cutoff(input_file, start_time=None, end_time=None, plot_path=None):
    """Main processing function with input seeking and plotting"""
    # Build ffmpeg command with input seeking
    ffmpeg_cmd = [
        'ffmpeg',
        '-hide_banner',
        '-loglevel', 'error',
    ]
    
    if start_time is not None:
        ffmpeg_cmd += ['-ss', str(start_time)]
    if end_time is not None:
        ffmpeg_cmd += ['-to', str(end_time)]
    
    ffmpeg_cmd += [
        '-i', input_file,
        '-ac', '1',
        '-ar', '44100',
        '-f', 's16le',
        '-'
    ]

    # Audio processing parameters
    sample_rate = 44100
    chunk_size = sample_rate * 10  # 10-second chunks
    bytes_per_sample = 2
    # cutoff_values = []
    final_cutoff = 0.0
    plot_data = None

    with subprocess.Popen(ffmpeg_cmd, stdout=subprocess.PIPE) as proc:
        chunk_num = 0
        while True:
            # Read 10-second chunk
            raw_bytes = proc.stdout.read(chunk_size * bytes_per_sample)
            if not raw_bytes:
                break

            # Convert to float32 audio
            audio = np.frombuffer(raw_bytes, dtype=np.int16).astype(np.float32) / 32768.0
            
            # Skip silent chunks
            if np.max(np.abs(audio)) < 0.01:  # -40 dBFS threshold
                print(f"Chunk {chunk_num}: Silent (skipped)")
                chunk_num += 1
                continue

            # Process chunk
            result = process_chunk(audio, sample_rate, chunk_num, start_time)
            if result is not None:
                cutoff, freqs, db = result
                # cutoff_values.append(cutoff)
                final_cutoff = max(cutoff, final_cutoff)
                
                if chunk_num % 6 == 0:
                  chunk_time = start_time + chunk_num * 10
                  print(f"t={chunk_time}sec f={final_cutoff/1000:.1f}kHz")

                # Store first valid chunk data for plotting
                if plot_path and plot_data is None:
                    plot_data = (freqs, db)
            
            chunk_num += 1

    # if not cutoff_values:
    if final_cutoff == 0.0:
        raise ValueError("No valid audio chunks processed")
    
    # Calculate final result using MAXIMUM value  # <--- Only changed line
    # final_cutoff = np.max(cutoff_values) / 1000
    final_cutoff = final_cutoff / 1000
    print(f"\nFinal lowpass cutoff frequency: {final_cutoff:.1f} kHz")

    # Generate plot
    if plot_path and plot_data is not None:
        freqs, db = plot_data
        plt.figure(figsize=(12, 6))
        plt.semilogx(freqs, db)
        plt.axvline(final_cutoff * 1000, color='r', linestyle='--',
                   label=f'Cutoff: {final_cutoff:.1f} kHz (-3dB)')
        plt.xlabel('Frequency (Hz)')
        plt.ylabel('Magnitude (dB)')
        plt.title('Lowpass Cutoff Analysis')
        plt.legend()
        plt.grid(True)
        plt.xlim(10000, 22000)
        plt.ylim(-60, 5)
        plt.savefig(plot_path)
        plt.close()

    return final_cutoff

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Detect audio lowpass cutoff frequency')
    parser.add_argument('input_file', help='Input audio file (M4A)')
    parser.add_argument('--ss', type=float, default=0.0, help='Start time in seconds')
    parser.add_argument('--to', type=float, help='End time in seconds')
    parser.add_argument('--plot', help='Save spectrum plot to file')
    args = parser.parse_args()

    try:
        cutoff = get_lowpass_cutoff(
            args.input_file,
            start_time=args.ss,
            end_time=args.to,
            plot_path=args.plot
        )
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
