#!/usr/bin/env python3

# generated by deepseek.com
# prompts:
"""
show me a python script
that takes an m4a file
(with aac audio)
and detects
the audio encoder's
lowpass filter
"cutoff frequency" in khz,
for example 20 khz
for high-quality audio,
or 10 khz for low-quality audio
"""
"""
please make matplotlib
write the debug plot
to a png file at
f"{input_file_path}.debug-spectrum.png".
also please avoid
creating a temporary wav file,
and try to use ffmpeg
to write wav data to stdout,
and feed that wav data
to wavfile and numpy.
generally,
try to use a streaming algorithm
to reduce memory usage.
"""
"""
no, this still runs out of memory at
```py
stdout_data, stderr_data = proc.communicate()
```
please use a loop to read
chunks of wav data from ffmpeg
and process each chunk separately.
feel free to use
a different format than wav
to make the code easier.
"""
"""
for debugging, print the
intermediate cutoff_khz result
with every loop iteration.
increase the buffer size
to make the loop run
at a lower frequency.
"""
"""
something is wrong here.
the script keeps printing 0 khz
but it should be about 19.6 khz
pretty much from the start
in my example.
"""
"""
now it keeps printing 1.5 kHz
but it should be about 19.6 khz.
im looking for
the maximum frequency of the signal
above a certain loudness,
dont count quiet noise spikes.
"""
"""
now the buffer size is too small,
so the intermediate result
is printed too often.
also, it always says
"Current peak: 0.5 kHz"
which is waay too low
"""
"""
now it prints 17.8 kHz
instead of 19.5 khz.
closer but still not perfect
"""
"""
you should
1. get the spectrogram of a chunk
2. remove noise (quiet signals)
3. use `numpy.argmax` on the spectrogram
to get the maximum frequency 
"""
"""
the script just hangs.
for debugging,
add a `--ss` and `--to n` option,
and pass them to ffmpeg as `-ss n` and `-to n`.
"""

#!/usr/bin/env python3

import numpy as np
import subprocess
import sys
import argparse
import matplotlib.pyplot as plt

def get_max_frequency(input_file, start_time=None, duration=None, plot_path=None):
    """Detect maximum frequency with seek/duration support"""
    # Build ffmpeg command
    ffmpeg_cmd = [
        'ffmpeg',
        '-hide_banner',
        '-loglevel', 'error'
    ]
    
    if start_time is not None:
        ffmpeg_cmd += ['-ss', str(start_time)]
    if duration is not None:
        ffmpeg_cmd += ['-to', str(start_time + duration) if start_time else str(duration)]
    
    ffmpeg_cmd += [
        '-i', input_file,
        '-ac', '1',
        '-ar', '44100',
        '-f', 's16le',
        '-'
    ]

    # Audio processing parameters
    chunk_seconds = 5  # Process in 5-second chunks
    sample_rate = 44100
    bytes_per_sample = 2
    chunk_size = sample_rate * chunk_seconds
    max_frequencies = []
    all_freqs = None
    db_spectrum = None

    # Calculate remaining duration if specified
    remaining = duration * sample_rate if duration else None
    
    with subprocess.Popen(ffmpeg_cmd, stdout=subprocess.PIPE) as proc:
        try:
            while True:
                # Adjust chunk size for remaining duration
                if remaining and remaining <= 0:
                    break
                    
                read_size = chunk_size * bytes_per_sample
                if remaining:
                    read_size = min(read_size, remaining * bytes_per_sample)
                    remaining -= chunk_size

                raw_bytes = proc.stdout.read(read_size)
                if not raw_bytes:
                    break

                # Convert to numpy array
                audio = np.frombuffer(raw_bytes, dtype=np.int16).astype(np.float32)
                audio /= 32768.0

                # Skip silent chunks
                if np.max(np.abs(audio)) < 0.01:
                    continue

                # Compute FFT
                window = np.hanning(len(audio))
                fft = np.fft.rfft(audio * window)
                freqs = np.fft.rfftfreq(len(audio), d=1/sample_rate)
                
                # Convert to dB scale
                magnitude = np.abs(fft)
                db = 20 * np.log10(magnitude + 1e-10)

                # Store for final plot
                if all_freqs is None:
                    all_freqs = freqs
                    db_spectrum = db
                else:
                    db_spectrum = np.maximum(db_spectrum, db)

                # Find maximum frequency above threshold
                valid = (freqs >= 10000) & (db >= -50)
                if np.any(valid):
                    max_idx = np.argmax(freqs[valid])
                    max_freq = freqs[valid][max_idx]
                    max_frequencies.append(max_freq)

        except KeyboardInterrupt:
            proc.terminate()

    if not max_frequencies:
        raise ValueError("No valid frequencies detected")

    # Calculate final cutoff (90th percentile)
    cutoff = np.percentile(max_frequencies, 90) / 1000

    # Generate debug plot
    if plot_path and all_freqs is not None:
        plt.figure(figsize=(12, 6))
        plt.semilogx(all_freqs, db_spectrum)
        plt.axvline(cutoff * 1000, color='r', linestyle='--',
                   label=f'Cutoff: {cutoff:.1f} kHz')
        plt.xlabel('Frequency (Hz)')
        plt.ylabel('Magnitude (dB)')
        plt.title('Frequency Spectrum Analysis')
        plt.legend()
        plt.grid(True)
        plt.xlim(1000, 20000)
        plt.savefig(plot_path)
        plt.close()

    return cutoff

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Detect audio lowpass cutoff frequency')
    parser.add_argument('input_file', help='Input audio file (M4A)')
    parser.add_argument('--ss', type=float, help='Start time in seconds')
    parser.add_argument('--to', type=float, help='End time in seconds')
    parser.add_argument('--plot', help='Save spectrum plot to file')
    args = parser.parse_args()

    try:
        duration = args.to - args.ss if (args.ss and args.to) else None
        cutoff = get_max_frequency(
            args.input_file,
            start_time=args.ss,
            duration=duration,
            plot_path=args.plot
        )
        print(f"Estimated lowpass cutoff: {cutoff:.1f} kHz")
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
