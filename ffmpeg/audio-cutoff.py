#!/usr/bin/env python3

# get the maximum frequency
# of an audio spectrum
# as an indicator
# of the actual audio quality

# generated by deepseek.com

# prompt
"""
create a python script
to detect the maximum frequency 
in an m4a audio file.
that maximum frequency is produced
by the lowpass filter
of the aac audio encoder.
high-quality audio
has a maximum frequency
around 20 KHz (fullband),
low-quality audio
has a maximum frequency
around 3 KHz (narrowband).
use ffmpeg to decode the audio
to pcm
in chunks of 10 seconds.
for each chunk:
detect the local maximum,
print the local maximum
and the chunk time
with the format
f"t={t}sec f={f}KHz",
update the global maximum.
to detect the local maximum,
remove the noise floor
around -97dB,
then find the maximum frequency
in the spectrum.
accept some command line options:
--ss n:
pass as "-ss n" to ffmpeg.
--to n:
pass as "-to n" to ffmpeg.
both -ss and -to args
must come before the -i arg
for ffmpeg input seeking.
print all frequencies in KHz.
add a shebang line before the script.
---
the script returns 0.22KHz
instead of 19.6KHz.
---
the script returns 22.05KHz
instead of 19.6KHz.
---
the script returns 0.25KHz
instead of 19.6KHz.
---
the script returns 23.99KHz
instead of 19.6KHz.
"""

#!/usr/bin/env python3
import argparse
import numpy as np
import subprocess
from scipy.signal import find_peaks

def parse_args():
    parser = argparse.ArgumentParser(description='Detect AAC encoder lowpass cutoff frequency')
    parser.add_argument('input_file', help='Input M4A audio file')
    parser.add_argument('--ss', type=float, help='Start time in seconds')
    parser.add_argument('--to', type=float, help='End time in seconds')
    return parser.parse_args()

def find_aac_cutoff(fft_db, freqs, sample_rate):
    """Specialized AAC lowpass cutoff detection"""
    # 1. Find the global maximum in the upper frequency range (10-20kHz)
    upper_band = (freqs > 10000) & (freqs < 20000)
    if not np.any(upper_band):
        return 0
    
    # 2. Find the point where spectrum drops by 20dB from peak
    max_idx = np.argmax(fft_db[upper_band])
    max_db = fft_db[upper_band][max_idx]
    cutoff_db = max_db - 20  # AAC typically has sharp drop
    
    # 3. Find the first frequency below cutoff after the peak
    for i in range(np.where(upper_band)[0][max_idx], len(fft_db)):
        if fft_db[i] < cutoff_db:
            return freqs[i]
    
    return freqs[-1]  # Return Nyquist if no drop found

def analyze_chunk(audio_data, sample_rate):
    # Convert and normalize audio
    audio_array = np.frombuffer(audio_data, dtype=np.int16).astype(np.float32) / 32768.0
    
    # Apply window function
    window = np.hanning(len(audio_array))
    audio_windowed = audio_array * window
    
    # Perform FFT with larger window
    fft_result = np.fft.rfft(audio_windowed, n=65536)  # Increased FFT size
    fft_magnitude = np.abs(fft_result)
    fft_db = 20 * np.log10(fft_magnitude + 1e-12)
    freqs = np.fft.rfftfreq(65536, d=1.0/sample_rate)
    
    return find_aac_cutoff(fft_db, freqs, sample_rate) / 1000  # kHz

def main():
    args = parse_args()
    
    # Configure FFmpeg with higher quality resampling
    ffmpeg_cmd = ['ffmpeg', '-hide_banner', '-loglevel', 'error']
    if args.ss: ffmpeg_cmd.extend(['-ss', str(args.ss)])
    if args.to: ffmpeg_cmd.extend(['-to', str(args.to)])
    
    ffmpeg_cmd.extend([
        '-i', args.input_file,
        '-f', 's16le', '-ac', '1', '-ar', '48000',
        '-af', 'aresample=resampler=soxr',  # High-quality resampling
        '-acodec', 'pcm_s16le', '-'
    ])
    
    chunk_duration = 5  # seconds
    sample_rate = 48000
    chunk_size = sample_rate * chunk_duration * 2
    
    print(f"Analyzing {args.input_file} for AAC lowpass cutoff...")
    
    cutoffs = []
    with subprocess.Popen(ffmpeg_cmd, stdout=subprocess.PIPE) as proc:
        while True:
            audio_data = proc.stdout.read(chunk_size)
            if not audio_data or len(audio_data) < chunk_size:
                break
            
            cutoff = analyze_chunk(audio_data, sample_rate)
            if 15 < cutoff < 22:  # Only collect plausible AAC cutoffs
                cutoffs.append(cutoff)
    
    if cutoffs:
        median_cutoff = np.median(cutoffs)
        print(f"\nDetected AAC lowpass cutoff: {median_cutoff:.2f}KHz")
        
        if median_cutoff > 19: print("Quality: Fullband (high quality)")
        elif median_cutoff > 16: print("Quality: Wideband (good quality)")
        elif median_cutoff > 12: print("Quality: Medium band")
        else: print("Quality: Narrowband")
    else:
        print("No valid AAC cutoff detected")

if __name__ == '__main__':
    main()
