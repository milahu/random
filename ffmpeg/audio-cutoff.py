#!/usr/bin/env python3

# get the maximum frequency
# of an audio spectrum
# as an indicator
# of the actual audio quality

# generated by deepseek.com

import numpy as np
import subprocess
import sys
import argparse
from scipy import signal

def process_chunk(audio, sample_rate, chunk_num):
    """Process 10-second audio chunk and return cutoff frequency estimate"""
    # Apply window function
    window = signal.windows.hann(len(audio))
    fft = np.fft.rfft(audio * window, n=len(audio)*4)  # 4x zero-padding
    freqs = np.fft.rfftfreq(len(audio)*4, d=1/sample_rate)
    db = 20 * np.log10(np.abs(fft) + 1e-10)
    
    # Analysis parameters
    # fixme this is wrong
    # min_freq has direct influence on result of 19.4 khz
    min_freq = 18000
    max_freq = 24000
    rolloff_db = 3
    
    # Find cutoff frequency
    mask = (freqs >= min_freq) & (freqs <= max_freq)
    target_freqs = freqs[mask]
    target_db = db[mask]
    
    if len(target_db) == 0:
        return None

    # Find peak and cutoff
    peak_idx = np.argmax(target_db)
    peak_db = target_db[peak_idx]
    cutoff_db = peak_db - rolloff_db
    
    above_threshold = np.where(target_db >= cutoff_db)[0]
    if len(above_threshold) == 0:
        return None
    
    cutoff_idx = above_threshold[-1]
    cutoff_freq = target_freqs[cutoff_idx]
    
    return cutoff_freq, freqs, db

def get_lowpass_cutoff(input_file, start_time=None, end_time=None, plot_path=None):
    """Main processing function with input seeking and plotting"""
    # Build ffmpeg command with input seeking
    ffmpeg_cmd = [
        'ffmpeg',
        '-hide_banner',
        '-loglevel', 'error',
    ]
    
    if start_time is not None:
        ffmpeg_cmd += ['-ss', str(start_time)]
    if end_time is not None:
        ffmpeg_cmd += ['-to', str(end_time)]
    
    ffmpeg_cmd += [
        '-i', input_file,
        '-ac', '1',
        '-ar', '44100',
        '-f', 's16le',
        '-'
    ]

    # Audio processing parameters
    sample_rate = 44100
    chunk_size = sample_rate * 10  # 10-second chunks
    bytes_per_sample = 2
    # cutoff_values = []
    final_cutoff = 0.0
    plot_data = None

    with subprocess.Popen(ffmpeg_cmd, stdout=subprocess.PIPE) as proc:
        chunk_num = 0
        while True:
            # Read 10-second chunk
            raw_bytes = proc.stdout.read(chunk_size * bytes_per_sample)
            if not raw_bytes:
                break

            # Convert to float32 audio
            audio = np.frombuffer(raw_bytes, dtype=np.int16).astype(np.float32) / 32768.0
            
            # Skip silent chunks
            if np.max(np.abs(audio)) < 0.01:  # -40 dBFS threshold
                print(f"Chunk {chunk_num}: Silent (skipped)")
                chunk_num += 1
                continue

            # Process chunk
            result = process_chunk(audio, sample_rate, chunk_num)
            if result is not None:
                cutoff, freqs, db = result
                # cutoff_values.append(cutoff)
                final_cutoff = max(cutoff, final_cutoff)
                
                if chunk_num % 6 == 0:
                  chunk_time = start_time + chunk_num * 10
                  print(f"t={chunk_time}sec f={final_cutoff/1000:.1f}kHz")

                # Store first valid chunk data for plotting
                if plot_path and plot_data is None:
                    plot_data = (freqs, db)
            
            chunk_num += 1

    # if not cutoff_values:
    if final_cutoff == 0.0:
        raise ValueError("No valid audio chunks processed")
    
    # Calculate final result using MAXIMUM value  # <--- Only changed line
    # final_cutoff = np.max(cutoff_values) / 1000
    final_cutoff = final_cutoff / 1000
    print(f"\nFinal lowpass cutoff frequency: {final_cutoff:.1f} kHz")

    # Generate plot
    if plot_path and plot_data is not None:
        import matplotlib.pyplot as plt
        freqs, db = plot_data
        plt.figure(figsize=(12, 6))
        plt.semilogx(freqs, db)
        plt.axvline(final_cutoff * 1000, color='r', linestyle='--',
                   label=f'Cutoff: {final_cutoff:.1f} kHz (-3dB)')
        plt.xlabel('Frequency (Hz)')
        plt.ylabel('Magnitude (dB)')
        plt.title('Lowpass Cutoff Analysis')
        plt.legend()
        plt.grid(True)
        plt.xlim(10000, 22000)
        plt.ylim(-60, 5)
        plt.savefig(plot_path)
        plt.close()

    return final_cutoff

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Detect audio lowpass cutoff frequency')
    parser.add_argument('input_file', help='Input audio file (M4A)')
    parser.add_argument('--ss', type=float, default=0.0, help='Start time in seconds')
    parser.add_argument('--to', type=float, help='End time in seconds')
    parser.add_argument('--plot', help='Save spectrum plot to file')
    args = parser.parse_args()

    try:
        cutoff = get_lowpass_cutoff(
            args.input_file,
            start_time=args.ss,
            end_time=args.to,
            plot_path=args.plot
        )
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
