#!/usr/bin/env python3

# get the maximum frequency
# of an audio spectrum
# as an indicator
# of the actual audio quality

# generated by deepseek.com

# prompt
"""
create a python script
to detect the maximum frequency 
in an m4a audio file.
that maximum frequency is produced
by the lowpass filter
of the aac audio encoder.
high-quality audio
has a maximum frequency
around 20 KHz (fullband),
low-quality audio
has a maximum frequency
around 3 KHz (narrowband).
use ffmpeg to decode the audio
to pcm
in chunks of 10 seconds.
for each chunk:
detect the local maximum,
print the local maximum
and the chunk time,
update the global maximum.
to detect the local maximum,
remove the noise floor
around -97dB,
then find the maximum frequency
in the spectrum.
accept some command line options:
--ss n:
pass as "-ss n" to ffmpeg.
--to n:
pass as "-to n" to ffmpeg.
both -ss and -to args
must come before the -i arg
for ffmpeg input seeking.
print all frequencies in KHz.
add a shebang line before the script.
"""

#!/usr/bin/env python3

import argparse
import numpy as np
import subprocess
import sys
from tempfile import NamedTemporaryFile

def parse_args():
    parser = argparse.ArgumentParser(description='Detect maximum frequency in M4A audio file')
    parser.add_argument('input_file', help='Input M4A audio file')
    parser.add_argument('--ss', type=float, help='Start time in seconds (passed to ffmpeg)')
    parser.add_argument('--to', type=float, help='End time in seconds (passed to ffmpeg)')
    return parser.parse_args()

def analyze_chunk(audio_data, sample_rate, chunk_start_time):
    # Convert bytes to numpy array of floats
    audio_array = np.frombuffer(audio_data, dtype=np.int16).astype(np.float32)
    
    # Apply FFT
    fft_result = np.fft.rfft(audio_array)
    fft_magnitude = np.abs(fft_result)
    
    # Convert to dB
    fft_db = 20 * np.log10(fft_magnitude + 1e-12)  # Add small value to avoid log(0)
    
    # Remove noise floor (around -97dB)
    threshold = -97
    fft_db_clean = np.where(fft_db > threshold, fft_db, -120)
    
    # Find the maximum frequency above threshold
    max_idx = np.argmax(fft_db_clean)
    max_freq = max_idx * sample_rate / len(audio_array)
    max_db = fft_db_clean[max_idx]
    
    # Only consider frequencies where the signal is significantly above noise
    if max_db > threshold:
        return max_freq / 1000  # Convert to kHz
    return 0

def main():
    args = parse_args()
    
    # Build ffmpeg command
    ffmpeg_cmd = ['ffmpeg', '-hide_banner', '-loglevel', 'error']
    
    if args.ss is not None:
        ffmpeg_cmd.extend(['-ss', str(args.ss)])
    if args.to is not None:
        ffmpeg_cmd.extend(['-to', str(args.to)])
    
    ffmpeg_cmd.extend([
        '-i', args.input_file,
        '-f', 's16le',          # 16-bit little-endian PCM
        '-ac', '1',             # mono
        '-ar', '44100',        # sample rate (standard for analysis)
        '-acodec', 'pcm_s16le', # output codec
        '-'
    ])
    
    global_max_freq = 0
    chunk_duration = 10  # seconds
    bytes_per_sample = 2  # 16-bit = 2 bytes
    sample_rate = 44100
    chunk_size = sample_rate * chunk_duration * bytes_per_sample
    
    print(f"Analyzing {args.input_file} in {chunk_duration}-second chunks...")
    print("Time (s)\tMax Freq (kHz)")
    
    with subprocess.Popen(ffmpeg_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as proc:
        chunk_num = 0
        while True:
            chunk_start_time = chunk_num * chunk_duration
            audio_data = proc.stdout.read(chunk_size)
            
            if not audio_data:
                break
            
            local_max = analyze_chunk(audio_data, sample_rate, chunk_start_time)
            print(f"{chunk_start_time:8.1f}\t{local_max:12.2f}")
            
            if local_max > global_max_freq:
                global_max_freq = local_max
            
            chunk_num += 1
    
    print("\nGlobal maximum frequency: {:.2f} kHz".format(global_max_freq))
    
    # Classify quality based on maximum frequency
    if global_max_freq > 18:
        print("Quality: Fullband (high quality)")
    elif global_max_freq > 7:
        print("Quality: Wideband (medium quality)")
    elif global_max_freq > 3:
        print("Quality: Narrowband (low quality)")
    else:
        print("Quality: Very narrowband (very low quality)")

if __name__ == '__main__':
    main()
