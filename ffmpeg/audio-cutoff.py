#!/usr/bin/env python3

# generated by deepseek.com
# prompts:
"""
show me a python script
that takes an m4a file
(with aac audio)
and detects
the audio encoder's
lowpass filter
"cutoff frequency" in khz,
for example 20 khz
for high-quality audio,
or 10 khz for low-quality audio
"""
"""
please make matplotlib
write the debug plot
to a png file at
f"{input_file_path}.debug-spectrum.png".
also please avoid
creating a temporary wav file,
and try to use ffmpeg
to write wav data to stdout,
and feed that wav data
to wavfile and numpy.
generally,
try to use a streaming algorithm
to reduce memory usage.
"""
"""
no, this still runs out of memory at
```py
stdout_data, stderr_data = proc.communicate()
```
please use a loop to read
chunks of wav data from ffmpeg
and process each chunk separately.
feel free to use
a different format than wav
to make the code easier.
"""
"""
for debugging, print the
intermediate cutoff_khz result
with every loop iteration.
increase the buffer size
to make the loop run
at a lower frequency.
"""
"""
something is wrong here.
the script keeps printing 0 khz
but it should be about 19.6 khz
pretty much from the start
in my example.
"""
"""
now it keeps printing 1.5 kHz
but it should be about 19.6 khz.
im looking for
the maximum frequency of the signal
above a certain loudness,
dont count quiet noise spikes.
"""
"""
now the buffer size is too small,
so the intermediate result
is printed too often.
also, it always says
"Current peak: 0.5 kHz"
which is waay too low
"""

#!/usr/bin/env python3

import numpy as np
from scipy import signal
import subprocess
import sys
import matplotlib.pyplot as plt
from queue import Queue
from threading import Thread

def read_stderr(proc, queue):
    """Read stderr in a background thread to prevent blocking"""
    while True:
        chunk = proc.stderr.read(1024)
        if not chunk:
            break
        queue.put(chunk)
    queue.put(None)

def process_audio_chunk(chunk, sample_rate, spectrum_sum, chunk_count, freqs):
    """Process individual audio chunks and update spectrum analysis"""
    # Normalize and apply window
    chunk = chunk / 32768.0
    window = signal.windows.hann(len(chunk))
    windowed = chunk * window
    
    # Compute scaled FFT
    fft = np.fft.rfft(windowed) * 2 / np.sum(window)  # Proper window compensation
    power = np.abs(fft) ** 2
    
    # Initialize or accumulate spectrum
    if spectrum_sum is None:
        spectrum_sum = power
        freqs = np.fft.rfftfreq(len(chunk), d=1/sample_rate)
    else:
        if len(spectrum_sum) != len(power):
            return spectrum_sum, freqs, chunk_count  # Skip size mismatch
        spectrum_sum += power
    
    return spectrum_sum, freqs, chunk_count + 1

def detect_lowpass_cutoff(m4a_file_path, plot_path=None):
    """Main detection function with robust streaming and analysis"""
    # FFmpeg configuration
    ffmpeg_cmd = [
        'ffmpeg', '-hide_banner',
        '-i', m4a_file_path,
        '-ac', '1',          # Mono
        '-ar', '44100',      # Sample rate
        '-f', 's16le',       # 16-bit little-endian PCM
        '-'
    ]

    # Audio processing parameters
    sample_rate = 44100
    chunk_duration = 5  # Seconds per chunk (balance between responsiveness and stability)
    chunk_size = sample_rate * chunk_duration
    bytes_per_sample = 2
    
    # Start FFmpeg process
    proc = subprocess.Popen(ffmpeg_cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        bufsize=chunk_size * bytes_per_sample * 2  # Double buffer for safety
    )

    # Start stderr reader
    err_queue = Queue()
    stderr_thread = Thread(target=read_stderr, args=(proc, err_queue))
    stderr_thread.daemon = True
    stderr_thread.start()

    spectrum_sum = None
    freqs = None
    chunk_count = 0
    cutoff_estimates = []

    try:
        while True:
            # Process stderr output
            while not err_queue.empty():
                chunk = err_queue.get()
                if chunk is None:
                    break
                sys.stderr.buffer.write(chunk)
                sys.stderr.flush()

            # Read audio data
            raw_bytes = proc.stdout.read(chunk_size * bytes_per_sample)
            if not raw_bytes:
                break

            # Convert to numpy array
            audio_chunk = np.frombuffer(raw_bytes, dtype=np.int16)

            # Skip silent chunks (threshold at -40dBFS)
            if np.max(np.abs(audio_chunk)) < 3276:  # 10% of max int16
                continue

            # Process chunk
            spectrum_sum, freqs, chunk_count = process_audio_chunk(
                audio_chunk, sample_rate, spectrum_sum, chunk_count, freqs
            )

            # Periodic analysis (every 3 chunks)
            if chunk_count > 0 and chunk_count % 3 == 0:
                current_db = 10 * np.log10(spectrum_sum / chunk_count + 1e-10)
                
                # Focus on 15-21kHz range
                mask = (freqs >= 15000) & (freqs <= 21000)
                if not np.any(mask):
                    continue
                
                target_db = current_db[mask]
                target_freqs = freqs[mask]
                
                # Find -3dB cutoff from peak
                peak_idx = np.argmax(target_db)
                peak_db = target_db[peak_idx]
                cutoff_db = peak_db - 3
                
                # Find highest frequency above cutoff
                above_threshold = np.where(target_db >= cutoff_db)[0]
                if len(above_threshold) > 0:
                    cutoff_freq = target_freqs[above_threshold[-1]]
                    cutoff_estimates.append(cutoff_freq / 1000)
                    print(f"Chunk {chunk_count}: Current estimate: {cutoff_freq/1000:.1f} kHz")

    except KeyboardInterrupt:
        print("\nProcessing interrupted")
    finally:
        proc.terminate()
        try:
            proc.wait(timeout=2)
        except:
            pass

    # Final analysis
    if chunk_count == 0:
        raise ValueError("No valid audio data processed")

    final_db = 10 * np.log10(spectrum_sum / chunk_count + 1e-10)
    mask = (freqs >= 15000) & (freqs <= 21000)
    target_db = final_db[mask]
    target_freqs = freqs[mask]

    # Calculate median of last 5 estimates
    final_cutoff = np.median(cutoff_estimates[-5:]) if cutoff_estimates else 0

    # Generate debug plot
    if plot_path:
        plt.figure(figsize=(12, 6))
        plt.plot(freqs, final_db)
        plt.axvline(final_cutoff * 1000, color='r', linestyle='--',
                   label=f'Estimated cutoff: {final_cutoff:.1f} kHz')
        plt.xlabel('Frequency (Hz)')
        plt.ylabel('Power (dB)')
        plt.title('Frequency Spectrum Analysis')
        plt.legend()
        plt.grid(True)
        plt.xlim(10000, 20000)
        plt.savefig(plot_path)
        plt.close()

    return final_cutoff

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python detect_lowpass.py <input.m4a>")
        sys.exit(1)

    try:
        cutoff = detect_lowpass_cutoff(sys.argv[1], f"{sys.argv[1]}.spectrum.png")
        print(f"\nFinal estimated lowpass cutoff: {cutoff:.1f} kHz")
    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        sys.exit(1)
